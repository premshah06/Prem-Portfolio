{"version":3,"file":"static/js/331.24016cbd.chunk.js","mappings":"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","sources":["../node_modules/@react-three/drei/core/Points.js","../node_modules/@react-three/drei/helpers/constants.js","../node_modules/@react-three/drei/core/PointMaterial.js","components/3d/SiliconBackground.jsx"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useFrame } from '@react-three/fiber';\n\nconst _inverseMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst _ray = /* @__PURE__ */new THREE.Ray();\nconst _sphere = /* @__PURE__ */new THREE.Sphere();\nconst _position = /* @__PURE__ */new THREE.Vector3();\nclass PositionPoint extends THREE.Group {\n  constructor() {\n    super();\n    this.size = 0;\n    this.color = new THREE.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  }\n\n  // This will allow the virtual instance have bounds\n  get geometry() {\n    var _this$instance$curren;\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  }\n  raycast(raycaster, intersects) {\n    var _raycaster$params$Poi, _raycaster$params$Poi2;\n    const parent = this.instance.current;\n    if (!parent || !parent.geometry) return;\n    const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n    // If the instance wasn't found or exceeds the parents draw range, bail out\n    if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n    const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n    _sphere.set(this.getWorldPosition(_position), threshold);\n    if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n    _inverseMatrix.copy(parent.matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const rayPointDistanceSq = _ray.distanceSqToPoint(this.position);\n    if (rayPointDistanceSq < localThresholdSq) {\n      const intersectPoint = new THREE.Vector3();\n      _ray.closestPointToPoint(this.position, intersectPoint);\n      intersectPoint.applyMatrix4(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n      if (distance < raycaster.near || distance > raycaster.far) return;\n      intersects.push({\n        distance: distance,\n        distanceToRay: Math.sqrt(rayPointDistanceSq),\n        point: intersectPoint,\n        index: instanceId,\n        face: null,\n        object: this\n      });\n    }\n  }\n}\nlet i, positionRef;\nconst context = /* @__PURE__ */React.createContext(null);\nconst parentMatrix = /* @__PURE__ */new THREE.Matrix4();\nconst position = /* @__PURE__ */new THREE.Vector3();\n\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */\nconst PointsInstances = /* @__PURE__ */React.forwardRef(({\n  children,\n  range,\n  limit = 1000,\n  ...props\n}, ref) => {\n  const parentRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => parentRef.current, []);\n  const [refs, setRefs] = React.useState([]);\n  const [[positions, colors, sizes]] = React.useState(() => [new Float32Array(limit * 3), Float32Array.from({\n    length: limit * 3\n  }, () => 1), Float32Array.from({\n    length: limit\n  }, () => 1)]);\n  React.useEffect(() => {\n    // We might be a frame too late? ðŸ¤·â€â™‚ï¸\n    parentRef.current.geometry.attributes.position.needsUpdate = true;\n  });\n  useFrame(() => {\n    parentRef.current.updateMatrix();\n    parentRef.current.updateMatrixWorld();\n    parentMatrix.copy(parentRef.current.matrixWorld).invert();\n    parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n    for (i = 0; i < refs.length; i++) {\n      positionRef = refs[i].current;\n      positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n      position.toArray(positions, i * 3);\n      parentRef.current.geometry.attributes.position.needsUpdate = true;\n      positionRef.matrixWorldNeedsUpdate = true;\n      positionRef.color.toArray(colors, i * 3);\n      parentRef.current.geometry.attributes.color.needsUpdate = true;\n      sizes.set([positionRef.size], i);\n      parentRef.current.geometry.attributes.size.needsUpdate = true;\n    }\n  });\n  const api = React.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setRefs(refs => [...refs, ref]);\n      return () => setRefs(refs => refs.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    userData: {\n      instances: refs\n    },\n    matrixAutoUpdate: false,\n    ref: parentRef,\n    raycast: () => null\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / 3,\n    array: positions,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / 3,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), /*#__PURE__*/React.createElement(context.Provider, {\n    value: api\n  }, children));\n});\nconst Point = /* @__PURE__ */React.forwardRef(({\n  children,\n  ...props\n}, ref) => {\n  React.useMemo(() => extend({\n    PositionPoint\n  }), []);\n  const group = React.useRef(null);\n  React.useImperativeHandle(ref, () => group.current, []);\n  const {\n    subscribe,\n    getParent\n  } = React.useContext(context);\n  React.useLayoutEffect(() => subscribe(group), []);\n  return /*#__PURE__*/React.createElement(\"positionPoint\", _extends({\n    instance: getParent(),\n    instanceKey: group,\n    ref: group\n  }, props), children);\n});\n\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */\n\nconst PointsBuffer = /* @__PURE__ */React.forwardRef(({\n  children,\n  positions,\n  colors,\n  sizes,\n  stride = 3,\n  ...props\n}, forwardedRef) => {\n  const pointsRef = React.useRef(null);\n  React.useImperativeHandle(forwardedRef, () => pointsRef.current, []);\n  useFrame(() => {\n    const attr = pointsRef.current.geometry.attributes;\n    attr.position.needsUpdate = true;\n    if (colors) attr.color.needsUpdate = true;\n    if (sizes) attr.size.needsUpdate = true;\n  });\n  return /*#__PURE__*/React.createElement(\"points\", _extends({\n    ref: pointsRef\n  }, props), /*#__PURE__*/React.createElement(\"bufferGeometry\", null, /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-position\",\n    count: positions.length / stride,\n    array: positions,\n    itemSize: stride,\n    usage: THREE.DynamicDrawUsage\n  }), colors && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-color\",\n    count: colors.length / stride,\n    array: colors,\n    itemSize: 3,\n    usage: THREE.DynamicDrawUsage\n  }), sizes && /*#__PURE__*/React.createElement(\"bufferAttribute\", {\n    attach: \"attributes-size\",\n    count: sizes.length / stride,\n    array: sizes,\n    itemSize: 1,\n    usage: THREE.DynamicDrawUsage\n  })), children);\n});\nconst Points = /* @__PURE__ */React.forwardRef((props, forwardedRef) => {\n  if (props.positions instanceof Float32Array) {\n    return /*#__PURE__*/React.createElement(PointsBuffer, _extends({}, props, {\n      ref: forwardedRef\n    }));\n  } else return /*#__PURE__*/React.createElement(PointsInstances, _extends({}, props, {\n    ref: forwardedRef\n  }));\n});\n\nexport { Point, Points, PointsBuffer, PositionPoint };\n","import { REVISION } from 'three';\n\nconst getVersion = () => parseInt(REVISION.replace(/\\D+/g, ''));\nconst version = /* @__PURE__ */getVersion();\n\nexport { version };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { version } from '../helpers/constants.js';\n\nconst opaque_fragment = version >= 154 ? 'opaque_fragment' : 'output_fragment';\nclass PointMaterialImpl extends THREE.PointsMaterial {\n  constructor(props) {\n    super(props);\n    this.onBeforeCompile = (shader, renderer) => {\n      const {\n        isWebGL2\n      } = renderer.capabilities;\n      shader.fragmentShader = shader.fragmentShader.replace(`#include <${opaque_fragment}>`, `\n        ${!isWebGL2 ? `#extension GL_OES_standard_derivatives : enable\\n#include <${opaque_fragment}>` : `#include <${opaque_fragment}>`}\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      float r = dot(cxy, cxy);\n      float delta = fwidth(r);     \n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n      `);\n    };\n  }\n}\nconst PointMaterial = /* @__PURE__ */React.forwardRef((props, ref) => {\n  const [material] = React.useState(() => new PointMaterialImpl(null));\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({}, props, {\n    object: material,\n    ref: ref,\n    attach: \"material\"\n  }));\n});\n\nexport { PointMaterial, PointMaterialImpl };\n","import React, { useMemo, useRef } from 'react';\r\nimport { useFrame } from '@react-three/fiber';\r\nimport { Points, PointMaterial } from '@react-three/drei';\r\nimport * as THREE from 'three';\r\n\r\nconst SiliconBackground = ({ quality = 'low' }) => {\r\n  const frameCount = useRef(0);\r\n  \r\n  // Optimized grid points with reduced count\r\n  const count = quality === 'high' ? 400 : 200;\r\n  const gridSize = 30;\r\n  \r\n  const points = useMemo(() => {\r\n    const points = new Float32Array(count * 3);\r\n    for (let i = 0; i < count; i++) {\r\n      const x = (Math.random() - 0.5) * gridSize;\r\n      const y = (Math.random() - 0.5) * gridSize;\r\n      const z = (Math.random() - 0.5) * 8;\r\n      points.set([x, y, z], i * 3);\r\n    }\r\n    return points;\r\n  }, [count, gridSize]);\r\n\r\n  // Optimized grid lines with fewer divisions\r\n  const gridLines = useMemo(() => {\r\n    const lines = [];\r\n    const size = gridSize / 2;\r\n    const divisions = quality === 'high' ? 12 : 8;\r\n    const step = size * 2 / divisions;\r\n\r\n    // Create horizontal and vertical lines\r\n    for (let i = -size; i <= size; i += step) {\r\n      // Horizontal lines\r\n      lines.push(\r\n        new THREE.Vector3(-size, i, 0),\r\n        new THREE.Vector3(size, i, 0)\r\n      );\r\n      // Vertical lines\r\n      lines.push(\r\n        new THREE.Vector3(i, -size, 0),\r\n        new THREE.Vector3(i, size, 0)\r\n      );\r\n    }\r\n\r\n    return new Float32Array(lines.flatMap(v => [v.x, v.y, v.z]));\r\n  }, [gridSize, quality]);\r\n\r\n  // Optimized animation with frame skipping\r\n  useFrame((state) => {\r\n    frameCount.current++;\r\n    \r\n    // Update camera position every 4th frame\r\n    if (frameCount.current % 4 === 0) {\r\n      const time = state.clock.getElapsedTime();\r\n      state.camera.position.z = THREE.MathUtils.lerp(\r\n        state.camera.position.z,\r\n        Math.sin(time / 3) * 1.5 + 12,\r\n        0.005\r\n      );\r\n    }\r\n  });\r\n\r\n  return (\r\n    <group>\r\n      {/* Grid points */}\r\n      <Points positions={points}>\r\n        <PointMaterial\r\n          transparent\r\n          color=\"#00D4FF\"\r\n          size={quality === 'high' ? 0.06 : 0.05}\r\n          sizeAttenuation={true}\r\n          depthWrite={false}\r\n          opacity={quality === 'high' ? 0.15 : 0.1}\r\n          blending={THREE.AdditiveBlending}\r\n        />\r\n      </Points>\r\n\r\n      {/* Grid lines - only show in high quality */}\r\n      {quality === 'high' && (\r\n        <lineSegments>\r\n          <bufferGeometry>\r\n            <bufferAttribute\r\n              attach=\"attributes-position\"\r\n              count={gridLines.length / 3}\r\n              array={gridLines}\r\n              itemSize={3}\r\n            />\r\n          </bufferGeometry>\r\n          <lineBasicMaterial\r\n            color=\"#00D4FF\"\r\n            transparent\r\n            opacity={0.08}\r\n            linewidth={1}\r\n          />\r\n        </lineSegments>\r\n      )}\r\n    </group>\r\n  );\r\n};\r\n\r\nexport default SiliconBackground;\r\n"],"names":["THREE","i","positionRef","context","React","parentMatrix","position","PointsInstances","_ref","ref","children","range","limit","props","_objectWithoutProperties","_excluded","parentRef","current","refs","setRefs","positions","colors","sizes","Float32Array","from","length","geometry","attributes","needsUpdate","useFrame","updateMatrix","updateMatrixWorld","copy","matrixWorld","invert","drawRange","count","Math","min","undefined","getWorldPosition","applyMatrix4","toArray","matrixWorldNeedsUpdate","color","set","size","api","getParent","subscribe","filter","item","_extends","userData","instances","matrixAutoUpdate","raycast","attach","array","itemSize","usage","Provider","value","PointsBuffer","_ref3","forwardedRef","stride","_excluded3","pointsRef","attr","Points","version","getVersion","parseInt","REVISION","replace","opaque_fragment","PointMaterialImpl","constructor","super","this","onBeforeCompile","shader","renderer","isWebGL2","capabilities","fragmentShader","concat","PointMaterial","material","object","quality","frameCount","useRef","points","useMemo","x","random","y","z","gridLines","lines","gridSize","step","push","flatMap","v","state","time","clock","getElapsedTime","camera","lerp","sin","_jsxs","_jsx","transparent","sizeAttenuation","depthWrite","opacity","blending","linewidth"],"sourceRoot":""}